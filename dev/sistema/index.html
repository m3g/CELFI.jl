<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sistema simulado · CELFI.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CELFI.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Início</a></li><li class="is-active"><a class="tocitem" href>Sistema simulado</a><ul class="internal"><li><a class="tocitem" href="#.1.-Parámetros-y-opciones-de-la-simulación"><span>2.1. Parámetros y opciones de la simulación</span></a></li><li><a class="tocitem" href="#.2.-Coordenadas-iniciales"><span>2.2. Coordenadas iniciales</span></a></li><li><a class="tocitem" href="#.3.-Minimización-de-la-energia"><span>2.3. Minimización de la energia</span></a></li><li><a class="tocitem" href="#.4.-Temperatura"><span>2.4. Temperatura</span></a></li><li><a class="tocitem" href="#.5.-Código-completo-resumido"><span>2.5. Código completo resumido</span></a></li></ul></li><li><a class="tocitem" href="../simple/">Simulación microcanónica</a></li><li><a class="tocitem" href="../isokinetic/">Termostato isocinético</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Sistema simulado</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sistema simulado</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/m3g/CELFI.jl/blob/master/docs/src/sistema.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Sistema-simulado"><a class="docs-heading-anchor" href="#Sistema-simulado">Sistema simulado</a><a id="Sistema-simulado-1"></a><a class="docs-heading-anchor-permalink" href="#Sistema-simulado" title="Permalink"></a></h1><p>La simulación es de un fluido de 100 partículas (mono-atómicas) que interactúan por un potencial de Lennard-Jones, en un sistema bi-dimensional, periódico.</p><p class="math-container">\[V = 4\epsilon \left( \frac{\sigma^{12}}{r^{12}} - \frac{\sigma^6}{r^6} \right)\]</p><p>Abra el archivo <a href="https://github.com/m3g/CELFI.jl/blob/master/src/potential.jl">potential.jl</a> y entienda la implementación del cálculo de la energía potencial. Note que el cálculo depende de 3 parámetros: <span>$\epsilon$</span>, <span>$\sigma$</span>, y el tamaño del sistema periódico. Los parámetros están definidos en la estructura de datos <code>opt</code>, de entrada (veremos más tarde como usarla). </p><p>El archivo <a href="https://github.com/m3g/CELFI.jl/blob/master/src/forces.jl">forces.jl</a> contiene el cálculo de las fuerzas (el gradiente del potencial), y el archivo <a href="https://github.com/m3g/CELFI.jl/blob/master/src/kinetic.jl">kinetic.jl</a> contiene el cálculo de la energía cinética. Como el sistema usa condiciones periódicas de contorno, las coordenadas tienen que siempre ser calculadas en relación a la imagen mínima. El cálculo de la imagen mínima está implementado en el archivo <a href="https://github.com/m3g/CELFI.jl/blob/master/src/image.jl">image.jl</a>. Es interesante entender la implementación de cada una de estas funciones, que son comunes a todos los métodos que vamos a describir. </p><h2 id=".1.-Parámetros-y-opciones-de-la-simulación"><a class="docs-heading-anchor" href="#.1.-Parámetros-y-opciones-de-la-simulación">2.1. Parámetros y opciones de la simulación</a><a id=".1.-Parámetros-y-opciones-de-la-simulación-1"></a><a class="docs-heading-anchor-permalink" href="#.1.-Parámetros-y-opciones-de-la-simulación" title="Permalink"></a></h2><p>Para inciar los trabajos, abra una sección de <code>Julia</code>, y dé el comando:</p><pre><code class="language-julia-repl">julia&gt; using CELFI</code></pre><p>Los parámetros de las simulaciones son controlados en la inicialización de la estructure <code>Options</code>, por ejemplo:</p><pre><code class="language-julia-repl">julia&gt; opt = Options(sides=[100,100],dt=0.01)
Options{Point2D}
-------------------
Simulation options:
-------------------
dt = 0.01
nsteps = 2000
sides = [100.0, 100.0]
eps = 1.0
sig = 2.0
kavg_target = 0.6
ibath = 1
printxyz = true
printvel = false
iprint = 1
iprintxyz = 2
trajectory_file = traj.xyz</code></pre><p>En este caso, ajustamos en tamaño del sistema y el paso de tiempo manualmente, y mantuvimos todas las otras opciones con valores default. Cada uno de estos paráemetros será discutido oportunamente. Note que definen el tamaño, campo de fuerza (<span>$\epsilon$</span> y <span>$\sigma$</span>), energía cinética (temperatura), y los nombres de los archivos de salida. </p><h2 id=".2.-Coordenadas-iniciales"><a class="docs-heading-anchor" href="#.2.-Coordenadas-iniciales">2.2. Coordenadas iniciales</a><a id=".2.-Coordenadas-iniciales-1"></a><a class="docs-heading-anchor-permalink" href="#.2.-Coordenadas-iniciales" title="Permalink"></a></h2><p>La coordenadas iniciales pueden ser creadas aleatoriamente, usando: </p><pre><code class="language-julia-repl">julia&gt; x = [ opt.sides .* rand(Point2D) for i in 1:100 ]
100-element Vector{Point}:
 [18.36579648764145, 7.711401822973363]
 [41.784092301135665, 45.61852102711508]
 [23.850299728474454, 63.797752122286425]
 ⋮
 [92.5679156243071, 39.272476774702206]
 [26.845528447086274, 92.88216539818639]
</code></pre><p>que genera <code>100</code> puntos en 2 dimensiones, aleatórios, con coordenadas entre <code>[0,0]</code> y <code>opt.sides = [100,100]</code>, en este caso. <code>Point2D</code> es un tipo de variable que representa un punto en dos dimensiones. Mas adelante vamos a ver que todo el código es genérico, y podemos hacer simulaciones en 3 dimensiones apenas modificando el tipo de variable asociado. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>El punto <code>.</code> en <code>.*</code> indica que es una multiplicación componente-a-componente, de cada componente del vector <code>opt.sides</code> por cada componente del vector associado a cada punto. </p></div></div><h2 id=".3.-Minimización-de-la-energia"><a class="docs-heading-anchor" href="#.3.-Minimización-de-la-energia">2.3. Minimización de la energia</a><a id=".3.-Minimización-de-la-energia-1"></a><a class="docs-heading-anchor-permalink" href="#.3.-Minimización-de-la-energia" title="Permalink"></a></h2><p>En seguida, el punto inicial va a ser modificado usando  el Método del Gradiente para minimizar la energía. El método consiste en mover las partículas según la aproximación de Taylor de orden uno, en la dirección de descenso de energía:</p><p class="math-container">\[\vec{x}_{i+1} = \vec{x}_i - \nabla V(\vec{x}_i) \Delta x\]</p><p>Si la energía en el punto <span>$\vec{x}_{i+1}$</span> es menor que la energía en el punto <span>$\vec{x}_i$</span>, se acepta el punto <span>$\vec{x}_{i+1}$</span> y el proceso es repetido. Si no, <span>$\Delta x$</span> es disminuido (<span>$\Delta x = \Delta x / 2$</span>), y un nuevo punto <span>$\vec{x}_{i+1}$</span> es calculado. Como la aproximación debe ser una buena aproximación en las cercanias del punto corriente (<span>$\vec{x}_i$</span>), un gradiente negativo garante que la función disminuye para <span>$\Delta x$</span> suficientemente pequeño. El proceso es interrumpido cuando la norma del gradiente es pequeña, o cuando demasiados puntos fueron testados. En mecánica, <span>$-\nabla V = \vec{F}$</span>, entonces la función que calcula el gradiente es la misma que calcula las fuerzas en la simulación. Abra el archivo <a href="https://github.com/m3g/CELFI.jl/blob/master/src/minimize.jl">minimize.jl</a> para discutir como se crea el punto inicial. </p><p>Antes de ejecutar la minimización de energia, vamos a copiar el punto inicial, para comparación:</p><pre><code class="language-julia-repl">julia&gt; x0 = copy(x)</code></pre><p>En seguida, minimizamos la energia con la función <code>minimize!</code>:</p><pre><code class="language-julia-repl">julia&gt; minimize!(x,opt)
Energy before minimization: 38322.72337856496
Energy after minimization: -74.15646912098042</code></pre><p>En <code>Julia</code> es una convención que las funciones que modifican sus argumentos terminan en <code>!</code>. En este caso, la función va a modificar las posiciones, <code>x</code>, de las partículas. </p><p>Podemos ver rapidamente que ocurrió con las particulas, colocando-las en un gráfico. Primero, generamos un gráfico de los puntos antes de la minimización:</p><pre><code class="language-julia-repl">julia&gt; using Plots

julia&gt; scatter(Tuple.(x0))</code></pre><p>Los puntos deben estar aleatoriamente distribuídos, y en particular algunos puntos deben estar muy cercanos a los otros, lo que genera potenciales muy repulsivos.</p><p>En seguida, hacemos el gráfico del punto con energia mínima obtenido:</p><pre><code class="language-julia-repl">julia&gt; scatter(Tuple.(x))</code></pre><p>y notará que los puntos ahora tienen una nueva disposición: hay puntos formando clusteres, porque el potencial de Lennard-Jones es atractivo en distáncias largas. Pero no hay más puntos muy cercanos generando repulsiones muy grandes.</p><p>Este punto inicial de energia mínima será usado en nuestras simulaciones. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Los gráficos puden ser salvos como figuras con <code>savefig(&quot;plot.pdf&quot;)</code>, por ejemplo.</p></div></div><h2 id=".4.-Temperatura"><a class="docs-heading-anchor" href="#.4.-Temperatura">2.4. Temperatura</a><a id=".4.-Temperatura-1"></a><a class="docs-heading-anchor-permalink" href="#.4.-Temperatura" title="Permalink"></a></h2><p>La temperatura del sistema es un parámetro también definido internamente en el programa (puede ser modificado a gusto, pero no lo haremos). La temperatura se define a partir energía cinética media asociada a cada grado de libertad de movimiento del sistema. En el caso que todos los movimientos pueden ser escritos como translaciones, la definición es</p><p class="math-container">\[\frac{1}{2}kT = \left&lt; \frac{1}{2} m v_x^2\right&gt;\]</p><p>donde la media, hecha sobre <span>$v_x$</span> aqui, es equivalente si hecha sobre cualquier otro grado de libertad de translación. En un sistema tridimensional, por lo tanto, </p><p class="math-container">\[\left&lt;\frac{1}{2}m |\vec{v}|^2 \right&gt; = 
\left&lt;\frac{1}{2}m \left(v_x^2 + v_y^2 + v_z^2\right) \right&gt; = 
3\left&lt; \frac{1}{2} m v_x^2 \right&gt; = \frac{3}{2}kT\]</p><p>que es el resultado usual.</p><p>Nuestras simulaciones son de un sistema bi-dimensional. En este caso,</p><p class="math-container">\[\left&lt; \frac{1}{2}m |\vec{v}|^2 \right&gt; = 
\left&lt; \frac{1}{2}m \left(v_x^2 + v_y^2\right)\right&gt; =
2\left&lt; \frac{1}{2}m v_x^2 \right&gt; = kT\]</p><p>En los códigos de dinámica molecular, la definición de temperatura se da, así, por la definición de la energía cinética media o, en este caso, por <span>$kT$</span>. En el código de Monte-Carlo la definición de temperatura se da por la tasa de aceptación, con la misma definición. </p><p>En todos los códigos fue escogido que se objetiva simular el sistema a la temperatura que corresponde a <span>$kT = 0.6$</span> unidades. Los sistemas simulados tiene 100 partículas, por lo tanto la energía cinética media es <span>$100kT=60$</span> unidades. Las velocidades iniciales van a ser generadas aleatoriamente al princípio de la simulación. </p><h2 id=".5.-Código-completo-resumido"><a class="docs-heading-anchor" href="#.5.-Código-completo-resumido">2.5. Código completo resumido</a><a id=".5.-Código-completo-resumido-1"></a><a class="docs-heading-anchor-permalink" href="#.5.-Código-completo-resumido" title="Permalink"></a></h2><pre><code class="language-julia">using CELFI, Plots
opt = Options(sides=[100,100],dt=0.01)
x = [ opt.sides .* rand(Point2D) for i in 1:100 ]
x0 = copy(x)
scatter(Tuple.(x0))
scatter(Tuple.(x))</code></pre><p>Observación: el comando <code>Tuple.(x)</code> convierte el vector de vectores en un vector de pares (tuplas), que es correctamente interpretado por <code>Plots</code> como una única série de puntos.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Início</a><a class="docs-footer-nextpage" href="../simple/">Simulación microcanónica »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.3 on <span class="colophon-date" title="Thursday 8 July 2021 17:27">Thursday 8 July 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
